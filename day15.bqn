If â† {ğ•âŸğ•@}Â´
inputâ†â€¢BQNâˆ˜â‹ˆÂ¨Ë˜>â€¢FLines "inputs/input15"

# generate 5x5 input
#inputâ†©{ğ•©â‰¥10 ? (10|ğ•©)+1 ; ğ•©}Â¨inputâ†©âˆ¾inputâŠ¸+Â¨+âŒœËœ5â¥Šâ†•5

# Neighbors
Nâ†(Ã—âˆ˜â‰ âŠ¢)Â¨âŠ¸/Â·{ğ•©/ËœÂ¬Ã—+Â´ğ•©>1-Ëœâ‰¢input}Â¨{
  0â€¿0: âŸ¨0â€¿1,1â€¿0âŸ© ;
  xâ€¿0: âŸ¨(x+1)â€¿0,(x-1)â€¿0, xâ€¿1âŸ© ;
  0â€¿y: âŸ¨0â€¿(y+1), 0â€¿(y-1), 1â€¿yâŸ© ;
  xâ€¿y: â·âŸ¨
    (x-1)â€¿y
    (x+1)â€¿y
    xâ€¿(y-1)
    xâ€¿(y+1)
  âŸ©
}

sâ†â‰¢input

# tentative distances
uâ†0âŒ¾(0â€¿0âŠ¸âŠ‘)sâ¥Šâˆ

# matrix tracking if a node has been accessed
mâ†sâ¥Š1

curâ†0â€¿0   # current node
tgtâ†1-Ëœs  # target node
csâ†âŸ¨âŸ©     # set of candidate nodes

Step â† {ğ•¤
  neigâ†N cur              # neighbors
  neigâ†©(0â‰ neigâŠ‘m)/neig    # take only unvisited neighbors
  If ((â‰ neig)>0)â€¿{ğ•¤
    csâ†©neigâˆ¾cs            # update the set of unvisited neighbors
    uâ†©{ğ•¤
      iâ†neigâŠ‘input
      câ†curâŠ‘u
      {ğ•Šinpâ€¿u: uâŒŠc+inp}Ë˜â‰iâ‰ğ•©
    }âŒ¾(neigâŠ¸âŠ‘) u          # update u matrix with correct distance values
  }
  m â†© 0âŒ¾(curâŠ¸âŠ‘) m         # update visit matrix
  cur â†© csâŠ‘ËœâŠ‘â‹csâŠ‘u        # update current node, use the smallest distance value from cs
  csâ†©((<cur)â‰¢Â¨cs)/cs      # remove current node from cs
  tgtâŠ‘u
}
risk â† Stepâˆ˜@â€¢_while_(=âŸœâˆ) âˆ
â€¢Show risk
