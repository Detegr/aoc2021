input â† â€¢FLines "inputs/input10"
parens â† "([{<)]}>"
opening â† 4â†‘parens
closing â† 4â†“parens
Opposing â† parensâŠ¸(4âŠ¸âŒ½âˆ˜â·ËœâŠ‘âˆ˜/âŠ£)

# star 1
# idea: keep state of opening parenthesis in `o`
#       and put unmatching closing parenthesis in `c`.
#       take first of c for first unmatching parenthesis
points â† 3â€¿57â€¿1197â€¿25137
_Solve â† {
  oâ†âŸ¨âŸ© â‹„ câ†âŸ¨âŸ©
  {
    (âŠ‘ğ•©âˆŠopening) ? oâ†©oâˆ¾ğ•©;
    (Opposing Â¯1âŠ‘o)=ğ•© ? oâ†©âŒ½1â†“âŒ½o ; câ†©câˆ¾ğ•©
  }Â¨ğ•©
  o ğ”½ c
}

â€¢Show +Â´âˆ¾/âŸœpointsÂ¨â·âŸœclosingÂ¨1âŠ¸â†‘Â¨âŠ¢_SolveÂ¨input

# star 2
# idea: the same algorithm modified so that
#       the return value is the opening parenthesis
#       that are not yet popped from `o`, reversed
#       and changed to opposing (closing) parenthesis

# Both work. The other one is cleaner in a way that there's no @ values
# in the resulting array, but huh it's a lot of symbols to do the same thing
# completions â† {(â‰ ğ•©)=0 ? (OpposingÂ¨âŒ½ğ•¨) ; @}_SolveÂ¨input
completions â† OpposingÂ¨âˆ˜âŒ½Â¨/ËœâŸœ(0âŠ¸â‰ âˆ˜â‰ Â¨âŠ¢)Â·/ËœâŸœ(0âŠ¸=âˆ˜â‰ âŠ¢)_SolveÂ¨input
solutionsâ†âˆ§Â¯1âŠ‘Â¨{ğ•©+ğ•¨Ã—5}`Â¨{1+âŠ‘/â·âŸœ(4â†“parens)ğ•©}Â¨Â¨(âŠ¢/Ëœ=Â¨)completions
â€¢Show solutionsâŠ‘ËœâŒŠ(â‰ solutions)Ã·2
