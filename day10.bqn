input â† â€¢FLines "input10"
parens â† "([{<)]}>"
Opening â† âŠ‘âˆ˜âˆŠâŸœ(4â†‘parens)
Closing â† Â¬âˆ˜Opening
Opposing â† {âŠ‘(4âŒ½ğ•©â·parens)/parens}

# star 1
# idea: keep state of opening parenthesis in `o`
#       and put unmatcheng closing parenthesis in `c`.
#       take first of c for first unmatching parenthesis
points â† 3â€¿57â€¿1197â€¿25137
â€¢Show +Â´âˆ¾{ğ•Š:
  oâ†âŸ¨âŸ©
  câ†âŸ¨âŸ©
  {
    (Opening ğ•©) ? oâ†©oâˆ¾ğ•©; {
      tgtâ†Opposing Â¯1âŠ‘o
      tgt=ğ•© ? oâ†©âŒ½1â†“âŒ½o ; {
        câ†©câˆ¾ğ•©
      }ğ•©
    }ğ•©
  }Â¨ğ•©
  âˆ¾/âŸœpointsÂ¨â·âŸœ(4â†“parens)Â¨âŠ‘câŸ{â‰ câ‰¥0} 0
}Â¨input

# star 2
# idea: the same algorithm modified so that
#       the return value is the opening parenthesis
#       that are not yet popped from `o`, reversed
#       and changed to opposing (closing) parenthesis
pointsâ†©1+â†•4
completionsâ†{ğ•Š:
  oâ†âŸ¨âŸ©
  câ†âŸ¨âŸ©
  {
    (Opening ğ•©) ? oâ†©oâˆ¾ğ•©; {
      tgtâ†Opposing Â¯1âŠ‘o
      tgt=ğ•© ? oâ†©âŒ½1â†“âŒ½o ; {
        câ†©câˆ¾ğ•©
      }ğ•©
    }ğ•©
  }Â¨ğ•©
  (â‰ c)=0 ? (OpposingÂ¨âŒ½o) ; @
}Â¨input

solutionsâ†âˆ§Â¯1âŠ‘Â¨{ğ•©+ğ•¨Ã—5}`Â¨(1âŠ¸+âˆ˜âŠ‘âˆ˜/â·âŸœ(4â†“parens))Â¨Â¨(âŠ¢/Ëœ=Â¨)completions
â€¢Show solutionsâŠ‘ËœâŒŠ(â‰ solutions)Ã·2
